# ä½¿ç”¨ `async` å’Œ `await`

*`async`/`await` æ”¯æŒç›®å‰æ­£åœ¨é›†æˆåˆ° PyO3 ä¸­ã€‚è¯·å‚è§ [ä¸“é—¨çš„æ–‡æ¡£](../async-await.md)*

å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ä¸€ä¸ªåˆ©ç”¨å¼‚æ­¥å‡½æ•°çš„ Python åº“ï¼Œæˆ–è€…å¸Œæœ›ä¸ºä¸€ä¸ªå¼‚æ­¥ Rust åº“æä¾› Python ç»‘å®šï¼Œ[`pyo3-asyncio`](https://github.com/awestlake87/pyo3-asyncio) å¯èƒ½å…·å¤‡æ‚¨æ‰€éœ€çš„å·¥å…·ã€‚å®ƒæä¾›äº† Python å’Œ Rust ä¸­å¼‚æ­¥å‡½æ•°ä¹‹é—´çš„è½¬æ¢ï¼Œå¹¶ä¸”ä¸ºæµè¡Œçš„ Rust è¿è¡Œæ—¶ï¼ˆå¦‚ [`tokio`](https://tokio.rs/) å’Œ [`async-std`](https://async.rs/)ï¼‰è®¾è®¡äº†ä¼˜å…ˆæ”¯æŒã€‚æ­¤å¤–ï¼Œæ‰€æœ‰å¼‚æ­¥ Python ä»£ç éƒ½åœ¨é»˜è®¤çš„ `asyncio` äº‹ä»¶å¾ªç¯ä¸Šè¿è¡Œï¼Œå› æ­¤ `pyo3-asyncio` åº”è¯¥å¯ä»¥å¾ˆå¥½åœ°ä¸ç°æœ‰çš„ Python åº“é…åˆä½¿ç”¨ã€‚

åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹ `pyo3-asyncio` è¿›è¡Œä¸€èˆ¬æ¦‚è¿°ï¼Œè§£é‡Šå¦‚ä½•ä½¿ç”¨ PyO3 è°ƒç”¨å¼‚æ­¥ Python å‡½æ•°ï¼Œå¦‚ä½•ä» Python è°ƒç”¨å¼‚æ­¥ Rust å‡½æ•°ï¼Œä»¥åŠå¦‚ä½•é…ç½®æ‚¨çš„ä»£ç åº“ä»¥ç®¡ç†ä¸¤è€…çš„è¿è¡Œæ—¶ã€‚

## å¿«é€Ÿå…¥é—¨

ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼Œå¸®åŠ©æ‚¨ç«‹å³å…¥é—¨ï¼è¿™äº›ç¤ºä¾‹ä¸­æ¦‚å¿µçš„æ›´è¯¦ç»†åˆ†è§£å¯ä»¥åœ¨åé¢çš„éƒ¨åˆ†æ‰¾åˆ°ã€‚

### Rust åº”ç”¨ç¨‹åº
åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åˆå§‹åŒ–è¿è¡Œæ—¶ï¼Œå¯¼å…¥ Python çš„ `asyncio` åº“ï¼Œå¹¶ä½¿ç”¨ Python çš„é»˜è®¤ `EventLoop` å’Œ `async-std` è¿è¡Œç»™å®šçš„æœªæ¥ã€‚åœ¨æœªæ¥å†…éƒ¨ï¼Œæˆ‘ä»¬å°† `asyncio` çš„ç¡çœ è½¬æ¢ä¸º Rust çš„æœªæ¥å¹¶ç­‰å¾…å®ƒã€‚

```toml
# Cargo.toml ä¾èµ–
[dependencies]
pyo3 = { version = "0.14" }
pyo3-asyncio = { version = "0.14", features = ["attributes", "async-std-runtime"] }
async-std = "1.9"
```

```rust
//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -> PyResult<()> {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import("asyncio")?;
        // å°† asyncio.sleep è½¬æ¢ä¸º Rust Future
        pyo3_asyncio::async_std::into_future(asyncio.call_method1("sleep", (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}
```

åŒæ ·çš„åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨ `tokio` æ¥ç¼–å†™ï¼Œä½¿ç”¨ `#[pyo3_asyncio::tokio::main]` å±æ€§ã€‚

```toml
# Cargo.toml ä¾èµ–
[dependencies]
pyo3 = { version = "0.14" }
pyo3-asyncio = { version = "0.14", features = ["attributes", "tokio-runtime"] }
tokio = "1.4"
```

```rust
//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -> PyResult<()> {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import("asyncio")?;
        // å°† asyncio.sleep è½¬æ¢ä¸º Rust Future
        pyo3_asyncio::tokio::into_future(asyncio.call_method1("sleep", (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}
```

æœ‰å…³æ­¤åº“ä½¿ç”¨çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [API æ–‡æ¡£](https://awestlake87.github.io/pyo3-asyncio/master/doc) å’Œä¸‹é¢çš„å…¥é—¨æŒ‡å—ã€‚

### PyO3 åŸç”Ÿ Rust æ¨¡å—

PyO3 Asyncio è¿˜å¯ä»¥ç”¨äºç¼–å†™å…·æœ‰å¼‚æ­¥å‡½æ•°çš„åŸç”Ÿæ¨¡å—ã€‚

åœ¨ `Cargo.toml` ä¸­æ·»åŠ  `[lib]` éƒ¨åˆ†ï¼Œä½¿æ‚¨çš„åº“æˆä¸º Python å¯ä»¥å¯¼å…¥çš„ `cdylib`ã€‚
```toml
[lib]
name = "my_async_module"
crate-type = ["cdylib"]
```

ä½¿æ‚¨çš„é¡¹ç›®ä¾èµ–äº `pyo3`ï¼Œå¹¶å¯ç”¨ `extension-module` ç‰¹æ€§ï¼Œå¹¶é€‰æ‹©æ‚¨çš„ `pyo3-asyncio` è¿è¡Œæ—¶ï¼š

å¯¹äº `async-std`ï¼š
```toml
[dependencies]
pyo3 = { version = "0.14", features = ["extension-module"] }
pyo3-asyncio = { version = "0.14", features = ["async-std-runtime"] }
async-std = "1.9"
```

å¯¹äº `tokio`ï¼š
```toml
[dependencies]
pyo3 = { version = "0.14", features = ["extension-module"] }
pyo3-asyncio = { version = "0.14", features = ["tokio-runtime"] }
tokio = "1.4"
```

å¯¼å‡ºä¸€ä¸ªä½¿ç”¨ `async-std` çš„å¼‚æ­¥å‡½æ•°ï¼š

```rust
//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {
    pyo3_asyncio::async_std::future_into_py(py, async {
        async_std::task::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)
}
```

å¦‚æœæ‚¨æƒ³ä½¿ç”¨ `tokio`ï¼Œæ‚¨çš„æ¨¡å—åº”å¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)
}
```

æ‚¨å¯ä»¥ä½¿ç”¨ maturin æ„å»ºæ‚¨çš„æ¨¡å—ï¼ˆæœ‰å…³è®¾ç½®è¯´æ˜ï¼Œè¯·å‚è§ PyO3 æŒ‡å—ä¸­çš„ [åœ¨ Python ä¸­ä½¿ç”¨ Rust](https://pyo3.rs/main/#using-rust-from-python) éƒ¨åˆ†ï¼‰ã€‚ä¹‹åï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿè¿è¡Œ Python REPL è¿›è¡Œå°è¯•ã€‚

```bash
maturin develop && python3
ğŸ”— æ‰¾åˆ° pyo3 ç»‘å®š
ğŸ æ‰¾åˆ° CPython 3.8 åœ¨ python3
    åœ¨ 0.04s å†…å®Œæˆå¼€å‘ [æœªä¼˜åŒ– + è°ƒè¯•ä¿¡æ¯] ç›®æ ‡
Python 3.8.5 (é»˜è®¤, 2021å¹´1æœˆ27æ—¥, 15:41:15)
[GCC 9.3.0] åœ¨ linux ä¸Š
è¾“å…¥ "help", "copyright", "credits" æˆ– "license" è·å–æ›´å¤šä¿¡æ¯ã€‚
>>> import asyncio
>>>
>>> from my_async_module import rust_sleep
>>>
>>> async def main():
>>>     await rust_sleep()
>>>
>>> # åº”è¯¥ç¡çœ  1 ç§’
>>> asyncio.run(main())
>>>
```

## åœ¨ Rust ä¸­ç­‰å¾…å¼‚æ­¥ Python å‡½æ•°

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªéå¸¸ç®€å•çš„å¼‚æ­¥ Python å‡½æ•°ï¼š

```python
# ç¡çœ  1 ç§’
async def py_sleep():
    await asyncio.sleep(1)
```

**Python ä¸­çš„å¼‚æ­¥å‡½æ•°åªæ˜¯è¿”å› `coroutine` å¯¹è±¡çš„å‡½æ•°**ã€‚å°±æˆ‘ä»¬çš„ç›®çš„è€Œè¨€ï¼Œæˆ‘ä»¬å®é™…ä¸Šä¸éœ€è¦äº†è§£è¿™äº› `coroutine` å¯¹è±¡ã€‚å…³é”®å› ç´ æ˜¯è°ƒç”¨å¼‚æ­¥å‡½æ•° _å°±åƒè°ƒç”¨å¸¸è§„å‡½æ•°_ ä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æˆ‘ä»¬å¿…é¡»å¯¹å®ƒè¿”å›çš„å¯¹è±¡åšä¸€äº›ç‰¹æ®Šå¤„ç†ã€‚

é€šå¸¸åœ¨ Python ä¸­ï¼Œè¿™ä¸ªç‰¹æ®Šçš„å¤„ç†æ˜¯ `await` å…³é”®å­—ï¼Œä½†ä¸ºäº†åœ¨ Rust ä¸­ç­‰å¾…è¿™ä¸ª `coroutine`ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å°†å…¶è½¬æ¢ä¸º Rust ç‰ˆæœ¬çš„ `coroutine`ï¼šä¸€ä¸ª `Future`ã€‚è¿™å°±æ˜¯ `pyo3-asyncio` çš„ç”¨æ­¦ä¹‹åœ°ã€‚
[`pyo3_asyncio::async_std::into_future`](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.into_future.html) ä¸ºæˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªè½¬æ¢ã€‚

ä»¥ä¸‹ç¤ºä¾‹ä½¿ç”¨ `into_future` è°ƒç”¨ä¸Šé¢æ˜¾ç¤ºçš„ `py_sleep` å‡½æ•°ï¼Œç„¶åç­‰å¾…ä»è°ƒç”¨è¿”å›çš„ `coroutine` å¯¹è±¡ï¼š

```rust
use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -> PyResult<()> {
    let future = Python::with_gil(|py| -> PyResult<_> {
        // å¯¼å…¥åŒ…å« py_sleep å‡½æ•°çš„æ¨¡å—
        let example = py.import("example")?;

        // åƒæ­£å¸¸å‡½æ•°ä¸€æ ·è°ƒç”¨ py_sleep æ–¹æ³•
        // è¿”å›ä¸€ä¸ª coroutine
        let coroutine = example.call_method0("py_sleep")?;

        // ä½¿ç”¨ tokio è¿è¡Œæ—¶å°† coroutine è½¬æ¢ä¸º Rust future
        pyo3_asyncio::tokio::into_future(coroutine)
    })?;

    // ç­‰å¾… future
    future.await?;

    Ok(())
}
```

æˆ–è€…ï¼Œä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ç¼–å†™ä¸€ä¸ª `#[pyfunction]`ï¼Œå®ƒä½¿ç”¨ `into_future` æ¥æ”¶å¹¶ç­‰å¾…ä¸€ä¸ª `coroutine` å‚æ•°ï¼š

```rust
#[pyfunction]
fn await_coro(coro: &Bound<'_, PyAny>) -> PyResult<()> {
    // ä½¿ç”¨ async_std è¿è¡Œæ—¶å°† coroutine è½¬æ¢ä¸º Rust future
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // ç­‰å¾… future
        f.await?;
        Ok(())
    })
}
```

è¿™å¯ä»¥ä» Python è°ƒç”¨ï¼š

```python
import asyncio

async def py_sleep():
    asyncio.sleep(1)

await_coro(py_sleep())
```

å¦‚æœæ‚¨æƒ³å°†å¯è°ƒç”¨å‡½æ•°ä¼ é€’ç»™ `#[pyfunction]`ï¼Œåˆ™ï¼ˆå³æœ€åä¸€è¡Œå˜ä¸º `await_coro(py_sleep)`ï¼‰ï¼Œåˆ™ä¸Šè¿°ç¤ºä¾‹éœ€è¦è°ƒæ•´ï¼Œä»¥é¦–å…ˆè°ƒç”¨å¯è°ƒç”¨å¯¹è±¡ä»¥è·å– `coroutine`ï¼š

```rust
#[pyfunction]
fn await_coro(callable: &Bound<'_, PyAny>) -> PyResult<()> {
    // é€šè¿‡è°ƒç”¨å¯è°ƒç”¨å¯¹è±¡è·å– coroutine
    let coro = callable.call0()?;

    // ä½¿ç”¨ async_std è¿è¡Œæ—¶å°† coroutine è½¬æ¢ä¸º Rust future
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // ç­‰å¾… future
        f.await?;
        Ok(())
    })
}
```

è¿™åœ¨æ‚¨éœ€è¦åå¤åˆ›å»ºå’Œç­‰å¾…ä¸€ä¸ª `coroutine` æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚å°è¯•å¤šæ¬¡ç­‰å¾…åŒä¸€ä¸ª `coroutine` å°†å¼•å‘é”™è¯¯ï¼š

```python
RuntimeError: cannot reuse already awaited coroutine
```

> å¦‚æœæ‚¨æœ‰å…´è¶£äº†è§£æ›´å¤šå…³äº `coroutines` å’Œ `awaitables` çš„ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹ [Python 3 `asyncio` æ–‡æ¡£](https://docs.python.org/3/library/asyncio-task.html)ã€‚

## åœ¨ Python ä¸­ç­‰å¾… Rust Future

è¿™é‡Œæˆ‘ä»¬æœ‰ä¸ä¹‹å‰ç›¸åŒçš„å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ [`async-std`](https://async.rs/) è¿è¡Œæ—¶ç¼–å†™ï¼š

```rust
/// ç¡çœ  1 ç§’
async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}
```

ä¸ Python ç±»ä¼¼ï¼ŒRust çš„å¼‚æ­¥å‡½æ•°ä¹Ÿè¿”å›ä¸€ä¸ªç‰¹æ®Šå¯¹è±¡ï¼Œç§°ä¸º `Future`ï¼š

```rust
let future = rust_sleep();
```

æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ª `Future` å¯¹è±¡è½¬æ¢ä¸º Pythonï¼Œä½¿å…¶å¯è¢« `await`ã€‚è¿™å‘Šè¯‰ Python æ‚¨å¯ä»¥ä½¿ç”¨ `await` å…³é”®å­—ä¸ä¹‹é…åˆä½¿ç”¨ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†è°ƒç”¨ [`pyo3_asyncio::async_std::future_into_py`](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html)ï¼š

```rust
use pyo3::prelude::*;

async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}

#[pyfunction]
fn call_rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {
    pyo3_asyncio::async_std::future_into_py(py, async move {
        rust_sleep().await;
        Ok(Python::with_gil(|py| py.None()))
    })
}
```

åœ¨ Python ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åƒè°ƒç”¨ä»»ä½•å…¶ä»–å¼‚æ­¥å‡½æ•°ä¸€æ ·è°ƒç”¨è¿™ä¸ª pyo3 å‡½æ•°ï¼š

```python
from example import call_rust_sleep

async def rust_sleep():
    await call_rust_sleep()
```

## ç®¡ç†äº‹ä»¶å¾ªç¯

Python çš„äº‹ä»¶å¾ªç¯éœ€è¦ä¸€äº›ç‰¹æ®Šå¤„ç†ï¼Œç‰¹åˆ«æ˜¯å…³äºä¸»çº¿ç¨‹çš„å¤„ç†ã€‚Python çš„ä¸€äº› `asyncio` ç‰¹æ€§ï¼Œå¦‚é€‚å½“çš„ä¿¡å·å¤„ç†ï¼Œéœ€è¦å¯¹ä¸»çº¿ç¨‹çš„æ§åˆ¶ï¼Œè¿™åœ¨ä¸ Rust çš„äº¤äº’ä¸­å¹¶ä¸æ€»æ˜¯å…¼å®¹ã€‚

å¹¸è¿çš„æ˜¯ï¼ŒRust çš„äº‹ä»¶å¾ªç¯ç›¸å½“çµæ´»ï¼Œå¹¶ä¸ _éœ€è¦_ æ§åˆ¶ä¸»çº¿ç¨‹ï¼Œå› æ­¤åœ¨ `pyo3-asyncio` ä¸­ï¼Œæˆ‘ä»¬å†³å®šå¤„ç† Rust/Python äº’æ“ä½œçš„æœ€ä½³æ–¹å¼æ˜¯å°†ä¸»çº¿ç¨‹äº¤ç»™ Pythonï¼Œå¹¶åœ¨åå°è¿è¡Œ Rust çš„äº‹ä»¶å¾ªç¯ã€‚ä¸å¹¸çš„æ˜¯ï¼Œç”±äºå¤§å¤šæ•°äº‹ä»¶å¾ªç¯å®ç° _æ›´å–œæ¬¢_ æ§åˆ¶ä¸»çº¿ç¨‹ï¼Œè¿™ä»ç„¶å¯èƒ½ä½¿æŸäº›äº‹æƒ…å˜å¾—å°´å°¬ã€‚

### PyO3 Asyncio åˆå§‹åŒ–

ç”±äº Python éœ€è¦æ§åˆ¶ä¸»çº¿ç¨‹ï¼Œæˆ‘ä»¬æ— æ³•ä½¿ç”¨ Rust è¿è¡Œæ—¶çš„æ–¹ä¾¿ proc å®æ¥å¤„ç† `main` å‡½æ•°æˆ– `#[test]` å‡½æ•°ã€‚ç›¸åï¼ŒPyO3 çš„åˆå§‹åŒ–å¿…é¡»åœ¨ `main` å‡½æ•°ä¸­å®Œæˆï¼Œå¹¶ä¸”ä¸»çº¿ç¨‹å¿…é¡»é˜»å¡åœ¨ [`pyo3_asyncio::async_std::run_until_complete`](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.run_until_complete.html) ä¸Šã€‚

ç”±äºæˆ‘ä»¬å¿…é¡»åœ¨è¿™äº›å‡½æ•°ä¹‹ä¸€ä¸Šé˜»å¡ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•ä½¿ç”¨ [`#[async_std::main]`](https://docs.rs/async-std/latest/async_std/attr.main.html) æˆ– [`#[tokio::main]`](https://docs.rs/tokio/1.1.0/tokio/attr.main.html)ï¼Œå› ä¸ºåœ¨å¼‚æ­¥å‡½æ•°ä¸­è¿›è¡Œé•¿æ—¶é—´é˜»å¡è°ƒç”¨å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚

> åœ¨å†…éƒ¨ï¼Œè¿™äº› `#[main]` proc å®è¢«æ‰©å±•ä¸ºç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼š
> ```rust
> fn main() {
>     // æ‚¨çš„å¼‚æ­¥ä¸»å‡½æ•°
>     async fn _main_impl() { /* ... */ }
>     Runtime::new().block_on(_main_impl());
> }
> ```
> åœ¨ç”± `block_on` é©±åŠ¨çš„ `Future` å†…éƒ¨è¿›è¡Œé•¿æ—¶é—´é˜»å¡è°ƒç”¨ä¼šé˜»æ­¢è¯¥çº¿ç¨‹æ‰§è¡Œå…¶ä»–ä»»ä½•æ“ä½œï¼Œå¹¶å¯èƒ½ç»™æŸäº›è¿è¡Œæ—¶å¸¦æ¥éº»çƒ¦ï¼ˆæ­¤å¤–ï¼Œè¿™å®é™…ä¸Šä¼šå¯¼è‡´å•çº¿ç¨‹è¿è¡Œæ—¶æ­»é”ï¼ï¼‰ã€‚è®¸å¤šè¿è¡Œæ—¶éƒ½æœ‰æŸç§ `spawn_blocking` æœºåˆ¶ï¼Œå¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ï¼Œä½†åŒæ ·ï¼Œç”±äºæˆ‘ä»¬éœ€è¦åœ¨ _ä¸»_ çº¿ç¨‹ä¸Šé˜»å¡ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•åœ¨è¿™é‡Œä½¿ç”¨ã€‚

å› æ­¤ï¼Œ`pyo3-asyncio` æä¾›äº†è‡ªå·±çš„ä¸€ç»„ proc å®æ¥ä¸ºæ‚¨æä¾›æ­¤åˆå§‹åŒ–ã€‚è¿™äº›å®æ—¨åœ¨é•œåƒ `async-std` å’Œ `tokio` çš„åˆå§‹åŒ–ï¼ŒåŒæ—¶æ»¡è¶³ Python è¿è¡Œæ—¶çš„éœ€æ±‚ã€‚

ä»¥ä¸‹æ˜¯ä½¿ç”¨ `async-std` è¿è¡Œæ—¶çš„ PyO3 åˆå§‹åŒ–çš„å®Œæ•´ç¤ºä¾‹ï¼š
```rust
use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -> PyResult<()> {
    // PyO3 å·²åˆå§‹åŒ– - å‡†å¤‡å°±ç»ª

    let fut = Python::with_gil(|py| -> PyResult<_> {
        let asyncio = py.import("asyncio")?;

        // å°† asyncio.sleep è½¬æ¢ä¸º Rust Future
        pyo3_asyncio::async_std::into_future(
            asyncio.call_method1("sleep", (1.into_py(py),))?
        )
    })?;

    fut.await?;

    Ok(())
}
```

### å…³äº `asyncio.run` çš„è¯´æ˜

åœ¨ Python 3.7+ ä¸­ï¼Œä½¿ç”¨ `asyncio` è¿è¡Œé¡¶å±‚åç¨‹çš„æ¨èæ–¹æ³•æ˜¯ä½¿ç”¨ `asyncio.run`ã€‚åœ¨ `v0.13` ä¸­ï¼Œæˆ‘ä»¬å»ºè®®ä¸è¦ä½¿ç”¨æ­¤å‡½æ•°ï¼Œå› ä¸ºåˆå§‹åŒ–å­˜åœ¨é—®é¢˜ï¼Œä½†åœ¨ `v0.14` ä¸­ï¼Œä½¿ç”¨æ­¤å‡½æ•°æ˜¯å®Œå…¨æœ‰æ•ˆçš„â€¦â€¦ä½†æœ‰ä¸€ä¸ªè­¦å‘Šã€‚

ç”±äºæˆ‘ä»¬çš„ Rust <--> Python è½¬æ¢éœ€è¦å¯¹ Python äº‹ä»¶å¾ªç¯çš„å¼•ç”¨ï¼Œè¿™å°±é€ æˆäº†é—®é¢˜ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª PyO3 Asyncio æ¨¡å—ï¼Œå®šä¹‰äº†ä¸€ä¸ªåƒä¹‹å‰ç¤ºä¾‹ä¸­çš„ `rust_sleep` å‡½æ•°ã€‚æ‚¨å¯èƒ½ä¼šåˆç†åœ°å‡è®¾å¯ä»¥ç›´æ¥å°†å…¶ä¼ é€’ç»™ `asyncio.run`ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```python
import asyncio

from my_async_module import rust_sleep

asyncio.run(rust_sleep())
```

æ‚¨å¯èƒ½ä¼šæƒŠè®¶åœ°å‘ç°è¿™ä¼šæŠ›å‡ºä¸€ä¸ªé”™è¯¯ï¼š
```bash
Traceback (most recent call last):
  File "example.py", line 5, in <module>
    asyncio.run(rust_sleep())
RuntimeError: no running event loop
```

å‘ç”Ÿçš„äº‹æƒ…æ˜¯æˆ‘ä»¬åœ¨æœªæ¥å®é™…ä¸Šåœ¨ `asyncio.run` åˆ›å»ºçš„äº‹ä»¶å¾ªç¯ä¸Šè¿è¡Œä¹‹å‰è°ƒç”¨äº† `rust_sleep`ã€‚è¿™è™½ç„¶åç›´è§‰ï¼Œä½†å´æ˜¯é¢„æœŸçš„è¡Œä¸ºï¼Œä¸å¹¸çš„æ˜¯ï¼Œåœ¨ PyO3 Asyncio æœ¬èº«ä¸­ä¼¼ä¹æ²¡æœ‰å¥½çš„è§£å†³æ–¹æ³•ã€‚

ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªç®€å•çš„å˜é€šæ–¹æ³•ä½¿è¿™ä¸ªç¤ºä¾‹æ­£å¸¸å·¥ä½œï¼š

```python
import asyncio

from my_async_module import rust_sleep

# è°ƒç”¨ main å°†ä»…æ„é€ ç¨åè°ƒç”¨ rust_sleep çš„ coroutineã€‚
# - è¿™ç¡®ä¿ rust_sleep åœ¨äº‹ä»¶å¾ªç¯è¿è¡Œæ—¶è¢«è°ƒç”¨ï¼Œè€Œä¸æ˜¯ä¹‹å‰ã€‚
async def main():
    await rust_sleep()

# åœ¨é¡¶å±‚è¿è¡Œ main() åç¨‹
asyncio.run(main())
```

### éæ ‡å‡† Python äº‹ä»¶å¾ªç¯

Python å…è®¸æ‚¨ä½¿ç”¨æ›¿ä»£é»˜è®¤ `asyncio` äº‹ä»¶å¾ªç¯çš„é€‰é¡¹ã€‚ä¸€ä¸ªæµè¡Œçš„æ›¿ä»£æ–¹æ¡ˆæ˜¯ `uvloop`ã€‚åœ¨ `v0.13` ä¸­ï¼Œä½¿ç”¨éæ ‡å‡†äº‹ä»¶å¾ªç¯æœ‰ç‚¹éº»çƒ¦ï¼Œä½†åœ¨ `v0.14` ä¸­ï¼Œè¿™å˜å¾—ç®€å•å¾—å¤šã€‚

#### åœ¨ PyO3 Asyncio åŸç”Ÿæ‰©å±•ä¸­ä½¿ç”¨ `uvloop`

```toml
# Cargo.toml

[lib]
name = "my_async_module"
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.14", features = ["extension-module"] }
pyo3-asyncio = { version = "0.14", features = ["tokio-runtime"] }
async-std = "1.9"
tokio = "1.4"
```

```rust
//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}
```

```bash
$ maturin develop && python3
ğŸ”— æ‰¾åˆ° pyo3 ç»‘å®š
ğŸ æ‰¾åˆ° CPython 3.8 åœ¨ python3
    åœ¨ 0.04s å†…å®Œæˆå¼€å‘ [æœªä¼˜åŒ– + è°ƒè¯•ä¿¡æ¯] ç›®æ ‡
Python 3.8.8 (é»˜è®¤, 2021å¹´4æœˆ13æ—¥, 19:58:26)
[GCC 7.3.0] :: Anaconda, Inc. åœ¨ linux ä¸Š
è¾“å…¥ "help", "copyright", "credits" æˆ– "license" è·å–æ›´å¤šä¿¡æ¯ã€‚
>>> import asyncio
>>> import uvloop
>>>
>>> import my_async_module
>>>
>>> uvloop.install()
>>>
>>> async def main():
...     await my_async_module.rust_sleep()
...
>>> asyncio.run(main())
>>>
```

#### åœ¨ Rust åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ `uvloop`

åœ¨ Rust åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ `uvloop` æœ‰ç‚¹æ£˜æ‰‹ï¼Œä½†ä»ç„¶å¯ä»¥é€šè¿‡ç›¸å¯¹è¾ƒå°‘çš„ä¿®æ”¹å®ç°ã€‚

ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘ä»¬æ— æ³•åœ¨éæ ‡å‡†äº‹ä»¶å¾ªç¯ä¸­ä½¿ç”¨ `#[pyo3_asyncio::<runtime>::main]` å±æ€§ã€‚è¿™æ˜¯å› ä¸º `#[pyo3_asyncio::<runtime>::main]` proc å®å¿…é¡»åœ¨æˆ‘ä»¬å¯ä»¥å®‰è£… `uvloop` ç­–ç•¥ä¹‹å‰ä¸ Python äº‹ä»¶å¾ªç¯è¿›è¡Œäº¤äº’ã€‚

```toml
[dependencies]
async-std = "1.9"
pyo3 = "0.14"
pyo3-asyncio = { version = "0.14", features = ["async-std-runtime"] }
```

```rust
//! main.rs

use pyo3::{prelude::*, types::PyType};

fn main() -> PyResult<()> {
    pyo3::prepare_freethreaded_python();

    Python::with_gil(|py| {
        let uvloop = py.import("uvloop")?;
        uvloop.call_method0("install")?;

        // å­˜å‚¨å¼•ç”¨ä»¥è¿›è¡Œæ–­è¨€
        let uvloop = PyObject::from(uvloop);

        pyo3_asyncio::async_std::run(py, async move {
            // éªŒè¯æˆ‘ä»¬æ˜¯å¦åœ¨ uvloop.Loop ä¸Š
            Python::with_gil(|py| -> PyResult<()> {
                assert!(pyo3_asyncio::async_std::get_current_loop(py)?.is_instance(
                    uvloop
                        .as_ref(py)
                        .getattr("Loop")?
                )?);
                Ok(())
            })?;

            async_std::task::sleep(std::time::Duration::from_secs(1)).await;

            Ok(())
        })
    })
}
```

## å…¶ä»–ä¿¡æ¯
- ä½¿ç”¨ pyo3-asyncio ç®¡ç†äº‹ä»¶å¾ªç¯å¼•ç”¨å¯èƒ½ä¼šå¾ˆæ£˜æ‰‹ã€‚è¯·å‚è§ [äº‹ä»¶å¾ªç¯å¼•ç”¨](https://docs.rs/pyo3-asyncio/#event-loop-references) çš„ API æ–‡æ¡£ï¼Œä»¥æ›´å¥½åœ°ç†è§£æ­¤åº“ä¸­äº‹ä»¶å¾ªç¯å¼•ç”¨çš„ç®¡ç†æ–¹å¼ã€‚
- æµ‹è¯• pyo3-asyncio åº“å’Œåº”ç”¨ç¨‹åºéœ€è¦ä¸€ä¸ªè‡ªå®šä¹‰æµ‹è¯•å·¥å…·ï¼Œå› ä¸º Python éœ€è¦æ§åˆ¶ä¸»çº¿ç¨‹ã€‚æ‚¨å¯ä»¥åœ¨ [API æ–‡æ¡£ä¸­çš„ `testing` æ¨¡å—](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/testing) ä¸­æ‰¾åˆ°æµ‹è¯•æŒ‡å—ã€‚