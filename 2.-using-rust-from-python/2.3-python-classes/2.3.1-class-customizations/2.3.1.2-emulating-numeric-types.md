# æ¨¡æ‹Ÿæ•°å€¼ç±»å‹

æ­¤æ—¶æˆ‘ä»¬æœ‰ä¸€ä¸ª `Number` ç±»ï¼Œä½†å®é™…ä¸Šæ— æ³•è¿›è¡Œä»»ä½•æ•°å­¦è¿ç®—ï¼

åœ¨ç»§ç»­ä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘å¦‚ä½•å¤„ç†æº¢å‡ºé—®é¢˜ã€‚æœ‰ä¸‰ç§æ˜æ˜¾çš„è§£å†³æ–¹æ¡ˆï¼š
- æˆ‘ä»¬å¯ä»¥åƒ Python çš„ `int` ä¸€æ ·å®ç°æ— é™ç²¾åº¦ã€‚ç„¶è€Œï¼Œè¿™æ ·ä¼šå¾ˆæ— èŠâ€”â€”æˆ‘ä»¬åªæ˜¯åœ¨é‡å¤é€ è½®å­ã€‚
- æˆ‘ä»¬å¯ä»¥åœ¨ `Number` æº¢å‡ºæ—¶æŠ›å‡ºå¼‚å¸¸ï¼Œä½†è¿™ä¼šä½¿ API ä½¿ç”¨èµ·æ¥å¾ˆç—›è‹¦ã€‚
- æˆ‘ä»¬å¯ä»¥åœ¨ `i32` çš„è¾¹ç•Œä¸Šè¿›è¡Œç¯ç»•ã€‚è¿™æ˜¯æˆ‘ä»¬åœ¨è¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬åªéœ€è½¬å‘åˆ° `i32` çš„ `wrapping_*` æ–¹æ³•ã€‚

### ä¿®å¤æ„é€ å‡½æ•°

è®©æˆ‘ä»¬è§£å†³ `Number` æ„é€ å‡½æ•°ä¸­çš„ç¬¬ä¸€ä¸ªæº¢å‡ºé—®é¢˜ï¼š

```python
from my_module import Number

n = Number(1 << 1337)
```

```text
å›æº¯ï¼ˆæœ€è¿‘çš„è°ƒç”¨æœ€åï¼‰ï¼š
  æ–‡ä»¶ "example.py"ï¼Œç¬¬ 3 è¡Œï¼Œåœ¨ <module>
    n = Number(1 << 1337)
OverflowError: Python int too large to convert to C long
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `#[pyo3(from_py_with = "...")]` å±æ€§æŒ‡å®šè‡ªå·±çš„æå–å‡½æ•°ï¼Œè€Œä¸æ˜¯ä¾èµ–é»˜è®¤çš„ [`FromPyObject`] æå–æ¥è§£æå‚æ•°ã€‚ä¸å¹¸çš„æ˜¯ï¼ŒPyO3 å¹¶æ²¡æœ‰æä¾›ç›´æ¥åŒ…è£… Python æ•´æ•°çš„æ–¹æ³•ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡ Python è°ƒç”¨æ¥æ©ç å¹¶å°†å…¶è½¬æ¢ä¸º `i32`ã€‚

```rust
# #![allow(dead_code)]
use pyo3::prelude::*;

fn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {
    let val = obj.call_method1("__and__", (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    //     ğŸ‘‡ è¿™æ•…æ„å¯¼è‡´æº¢å‡ºï¼
    Ok(val as i32)
}
```
æˆ‘ä»¬è¿˜é€šè¿‡ `///` æ³¨é‡Šæ·»åŠ äº†æ–‡æ¡£ï¼Œè¿™äº›æ–‡æ¡£å¯¹ Python ç”¨æˆ·å¯è§ã€‚

```rust
# #![allow(dead_code)]
use pyo3::prelude::*;

fn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {
    let val = obj.call_method1("__and__", (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    Ok(val as i32)
}

/// ä½ å¬è¯´è¿‡è¾¾æ–¯Â·ç­¾åæº¢å‡ºè€…çš„æ‚²å‰§å—ï¼Ÿæˆ‘æƒ³æ²¡æœ‰ã€‚
/// è¿™ä¸æ˜¯ C ä¼šå‘Šè¯‰ä½ çš„æ•…äº‹ã€‚è¿™æ˜¯ä¸€ä¸ª Rust ä¼ å¥‡ã€‚
#[pyclass(module = "my_module")]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(#[pyo3(from_py_with = "wrap")] value: i32) -> Self {
        Self(value)
    }
}
```

è§£å†³äº†è¿™ä¸ªé—®é¢˜åï¼Œè®©æˆ‘ä»¬å®ç°ä¸€äº›è¿ç®—ç¬¦ï¼š
```rust
use pyo3::exceptions::{PyZeroDivisionError, PyValueError};

# use pyo3::prelude::*;
#
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __add__(&self, other: &Self) -> Self {
        Self(self.0.wrapping_add(other.0))
    }

    fn __sub__(&self, other: &Self) -> Self {
        Self(self.0.wrapping_sub(other.0))
    }

    fn __mul__(&self, other: &Self) -> Self {
        Self(self.0.wrapping_mul(other.0))
    }

    fn __truediv__(&self, other: &Self) -> PyResult<Self> {
        match self.0.checked_div(other.0) {
            Some(i) => Ok(Self(i)),
            None => Err(PyZeroDivisionError::new_err("é™¤ä»¥é›¶")),
        }
    }

    fn __floordiv__(&self, other: &Self) -> PyResult<Self> {
        match self.0.checked_div(other.0) {
            Some(i) => Ok(Self(i)),
            None => Err(PyZeroDivisionError::new_err("é™¤ä»¥é›¶")),
        }
    }

    fn __rshift__(&self, other: &Self) -> PyResult<Self> {
        match other.0.try_into() {
            Ok(rhs) => Ok(Self(self.0.wrapping_shr(rhs))),
            Err(_) => Err(PyValueError::new_err("è´Ÿç§»ä½è®¡æ•°")),
        }
    }

    fn __lshift__(&self, other: &Self) -> PyResult<Self> {
        match other.0.try_into() {
            Ok(rhs) => Ok(Self(self.0.wrapping_shl(rhs))),
            Err(_) => Err(PyValueError::new_err("è´Ÿç§»ä½è®¡æ•°")),
        }
    }
}
```

### ä¸€å…ƒç®—æœ¯è¿ç®—

```rust
# use pyo3::prelude::*;
#
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __pos__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
        slf
    }

    fn __neg__(&self) -> Self {
        Self(-self.0)
    }

    fn __abs__(&self) -> Self {
        Self(self.0.abs())
    }

    fn __invert__(&self) -> Self {
        Self(!self.0)
    }
}
```

### æ”¯æŒ `complex()`ã€`int()` å’Œ `float()` å†…ç½®å‡½æ•°ã€‚

```rust
# use pyo3::prelude::*;
#
# #[pyclass]
# struct Number(i32);
#
use pyo3::types::PyComplex;

#[pymethods]
impl Number {
    fn __int__(&self) -> i32 {
        self.0
    }

    fn __float__(&self) -> f64 {
        self.0 as f64
    }

    fn __complex__<'py>(&self, py: Python<'py>) -> Bound<'py, PyComplex> {
        PyComplex::from_doubles_bound(py, self.0 as f64, 0.0)
    }
}
```

æˆ‘ä»¬ä¸å®ç°åƒ `__iadd__` è¿™æ ·çš„å°±åœ°æ“ä½œï¼Œå› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›ä¿®æ”¹ `Number`ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿä¸æ‰“ç®—æ”¯æŒä¸åŒç±»å‹çš„æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿä¸å®ç°åå°„æ“ä½œï¼Œå¦‚ `__radd__`ã€‚

ç°åœ¨ Python å¯ä»¥ä½¿ç”¨æˆ‘ä»¬çš„ `Number` ç±»ï¼š

```python
from my_module import Number

def hash_djb2(s: str):
	'''
	ä¸¹å°¼å°”Â·JÂ·ä¼¯æ©æ–¯å¦çš„ djb2 å­—ç¬¦ä¸²å“ˆå¸Œç®—æ³•çš„ä¸€ä¸ªç‰ˆæœ¬
	åƒè®¸å¤šå“ˆå¸Œç®—æ³•ä¸€æ ·ï¼Œå®ƒä¾èµ–äºæ•´æ•°ç¯ç»•ã€‚
	'''

	n = Number(0)
	five = Number(5)

	for x in s:
		n = Number(ord(x)) + ((n << five) - n)
	return n

assert hash_djb2('l50_50') == Number(-1152549421)
```

### æœ€ç»ˆä»£ç 

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use pyo3::exceptions::{PyValueError, PyZeroDivisionError};
use pyo3::prelude::*;
use pyo3::class::basic::CompareOp;
use pyo3::types::{PyComplex, PyString};

fn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {
    let val = obj.call_method1("__and__", (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    Ok(val as i32)
}
/// ä½ å¬è¯´è¿‡è¾¾æ–¯Â·ç­¾åæº¢å‡ºè€…çš„æ‚²å‰§å—ï¼Ÿæˆ‘æƒ³æ²¡æœ‰ã€‚
/// è¿™ä¸æ˜¯ C ä¼šå‘Šè¯‰ä½ çš„æ•…äº‹ã€‚è¿™æ˜¯ä¸€ä¸ª Rust ä¼ å¥‡ã€‚
#[pyclass(module = "my_module")]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(#[pyo3(from_py_with = "wrap")] value: i32) -> Self {
        Self(value)
    }

    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {
       // åŠ¨æ€è·å–ç±»åï¼Œä»¥é˜² `Number` è¢«å­ç±»åŒ–
       let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;
        Ok(format!("{}({})", class_name, slf.borrow().0))
    }

    fn __str__(&self) -> String {
        self.0.to_string()
    }

    fn __hash__(&self) -> u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&mut hasher);
        hasher.finish()
    }

    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {
        match op {
            CompareOp::Lt => Ok(self.0 < other.0),
            CompareOp::Le => Ok(self.0 <= other.0),
            CompareOp::Eq => Ok(self.0 == other.0),
            CompareOp::Ne => Ok(self.0 != other.0),
            CompareOp::Gt => Ok(self.0 > other.0),
            CompareOp::Ge => Ok(self.0 >= other.0),
        }
    }

    fn __bool__(&self) -> bool {
        self.0 != 0
    }

    fn __add__(&self, other: &Self) -> Self {
        Self(self.0.wrapping_add(other.0))
    }

    fn __sub__(&self, other: &Self) -> Self {
        Self(self.0.wrapping_sub(other.0))
    }

    fn __mul__(&self, other: &Self) -> Self {
        Self(self.0.wrapping_mul(other.0))
    }

    fn __truediv__(&self, other: &Self) -> PyResult<Self> {
        match self.0.checked_div(other.0) {
            Some(i) => Ok(Self(i)),
            None => Err(PyZeroDivisionError::new_err("é™¤ä»¥é›¶")),
        }
    }

    fn __floordiv__(&self, other: &Self) -> PyResult<Self> {
        match self.0.checked_div(other.0) {
            Some(i) => Ok(Self(i)),
            None => Err(PyZeroDivisionError::new_err("é™¤ä»¥é›¶")),
        }
    }

    fn __rshift__(&self, other: &Self) -> PyResult<Self> {
        match other.0.try_into() {
            Ok(rhs) => Ok(Self(self.0.wrapping_shr(rhs))),
            Err(_) => Err(PyValueError::new_err("è´Ÿç§»ä½è®¡æ•°")),
        }
    }

    fn __lshift__(&self, other: &Self) -> PyResult<Self> {
        match other.0.try_into() {
            Ok(rhs) => Ok(Self(self.0.wrapping_shl(rhs))),
            Err(_) => Err(PyValueError::new_err("è´Ÿç§»ä½è®¡æ•°")),
        }
    }

    fn __xor__(&self, other: &Self) -> Self {
        Self(self.0 ^ other.0)
    }

    fn __or__(&self, other: &Self) -> Self {
        Self(self.0 | other.0)
    }

    fn __and__(&self, other: &Self) -> Self {
        Self(self.0 & other.0)
    }

    fn __int__(&self) -> i32 {
        self.0
    }

    fn __float__(&self) -> f64 {
        self.0 as f64
    }

    fn __complex__<'py>(&self, py: Python<'py>) -> Bound<'py, PyComplex> {
        PyComplex::from_doubles_bound(py, self.0 as f64, 0.0)
    }
}

#[pymodule]
fn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Number>()?;
    Ok(())
}
# const SCRIPT: &'static str = r#"
# def hash_djb2(s: str):
#     n = Number(0)
#     five = Number(5)
#
#     for x in s:
#         n = Number(ord(x)) + ((n << five) - n)
#     return n
#
# assert hash_djb2('l50_50') == Number(-1152549421)
# assert hash_djb2('logo') == Number(3327403)
# assert hash_djb2('horizon') == Number(1097468315)
#
#
# assert Number(2) + Number(2) == Number(4)
# assert Number(2) + Number(2) != Number(5)
#
# assert Number(13) - Number(7) == Number(6)
# assert Number(13) - Number(-7) == Number(20)
#
# assert Number(13) / Number(7) == Number(1)
# assert Number(13) // Number(7) == Number(1)
#
# assert Number(13) * Number(7) == Number(13*7)
#
# assert Number(13) > Number(7)
# assert Number(13) < Number(20)
# assert Number(13) == Number(13)
# assert Number(13) >= Number(7)
# assert Number(13) <= Number(20)
# assert Number(13) == Number(13)
#
#
# assert (True if Number(1) else False)
# assert (False if Number(0) else True)
#
#
# assert int(Number(13)) == 13
# assert float(Number(13)) == 13
# assert Number.__doc__ == "ä½ å¬è¯´è¿‡è¾¾æ–¯Â·ç­¾åæº¢å‡ºè€…çš„æ‚²å‰§å—ï¼Ÿæˆ‘æƒ³æ²¡æœ‰ã€‚\nè¿™ä¸æ˜¯ C ä¼šå‘Šè¯‰ä½ çš„æ•…äº‹ã€‚è¿™æ˜¯ä¸€ä¸ª Rust ä¼ å¥‡ã€‚"
# assert Number(12345234523452) == Number(1498514748)
# try:
#     import inspect
#     assert inspect.signature(Number).__str__() == '(value)'
# except ValueError:
#     # åœ¨ Python 3.10 ä¹‹å‰ï¼Œ`abi3` ä¸æ”¯æŒ
#     pass
# assert Number(1337).__str__() == '1337'
# assert Number(1337).__repr__() == 'Number(1337)'
"#;

#
# use pyo3::PyTypeInfo;
#
# fn main() -> PyResult<()> {
#     Python::with_gil(|py| -> PyResult<()> {
#         let globals = PyModule::import_bound(py, "__main__")?.dict();
#         globals.set_item("Number", Number::type_object_bound(py))?;
#
#         py.run_bound(SCRIPT, Some(&globals), None)?;
#         Ok(())
#     })
# }
```

## é™„å½•ï¼šç¼–å†™ä¸€äº›ä¸å®‰å…¨çš„ä»£ç 

åœ¨æœ¬ç« å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬æåˆ° PyO3 å¹¶æ²¡æœ‰æä¾›ç›´æ¥åŒ…è£… Python æ•´æ•°çš„æ–¹æ³•ï¼Œä½†è¿™åªæ˜¯éƒ¨åˆ†çœŸç›¸ã€‚è™½ç„¶æ²¡æœ‰ PyO3 APIï¼Œä½†æœ‰ä¸€ä¸ª Python C API å‡½æ•°å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š

```c
unsigned long PyLong_AsUnsignedLongMask(PyObject *obj)
```

æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ [`pyo3::ffi::PyLong_AsUnsignedLongMask`] ä» Rust è°ƒç”¨æ­¤å‡½æ•°ã€‚è¿™æ˜¯ä¸€ä¸ª *ä¸å®‰å…¨* çš„å‡½æ•°ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»ä½¿ç”¨ä¸å®‰å…¨å—æ¥è°ƒç”¨å®ƒï¼Œå¹¶å¯¹ç»´æŠ¤æ­¤å‡½æ•°çš„å¥‘çº¦è´Ÿè´£ã€‚è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹è¿™äº›å¥‘çº¦ï¼š
- å¿…é¡»æŒæœ‰ GILã€‚å¦‚æœæ²¡æœ‰ï¼Œè°ƒç”¨æ­¤å‡½æ•°ä¼šå¯¼è‡´æ•°æ®ç«äº‰ã€‚
- æŒ‡é’ˆå¿…é¡»æœ‰æ•ˆï¼Œå³å®ƒå¿…é¡»æ­£ç¡®å¯¹é½å¹¶æŒ‡å‘æœ‰æ•ˆçš„ Python å¯¹è±¡ã€‚

è®©æˆ‘ä»¬åˆ›å»ºé‚£ä¸ªè¾…åŠ©å‡½æ•°ã€‚ç­¾åå¿…é¡»æ˜¯ `fn(&Bound<'_, PyAny>) -> PyResult<T>`ã€‚
- `&Bound<'_, PyAny>` è¡¨ç¤ºä¸€ä¸ªç»è¿‡æ£€æŸ¥çš„å€Ÿç”¨å¼•ç”¨ï¼Œå› æ­¤ä»ä¸­æ´¾ç”Ÿçš„æŒ‡é’ˆæ˜¯æœ‰æ•ˆçš„ï¼ˆä¸”ä¸ä¸º nullï¼‰ã€‚
- æ¯å½“æˆ‘ä»¬åœ¨ä½œç”¨åŸŸå†…æœ‰å¯¹ Python å¯¹è±¡çš„å€Ÿç”¨å¼•ç”¨æ—¶ï¼Œä¿è¯ GIL æ˜¯æŒæœ‰çš„ã€‚è¿™ä¸ªå¼•ç”¨ä¹Ÿæ˜¯æˆ‘ä»¬å¯ä»¥è·å– [`Python`] ä»¤ç‰Œä»¥åœ¨è°ƒç”¨ [`PyErr::take`] æ—¶ä½¿ç”¨çš„åœ°æ–¹ã€‚

```rust
# #![allow(dead_code)]
use std::os::raw::c_ulong;
use pyo3::prelude::*;
use pyo3::ffi;

fn wrap(obj: &Bound<'_, PyAny>) -> Result<i32, PyErr> {
    let py: Python<'_> = obj.py();

    unsafe {
        let ptr = obj.as_ptr();

        let ret: c_ulong = ffi::PyLong_AsUnsignedLongMask(ptr);
        if ret == c_ulong::MAX {
            if let Some(err) = PyErr::take(py) {
                return Err(err);
            }
        }

        Ok(ret as i32)
    }
}
```

[`PyErr::take`]: {{#PYO3_DOCS_URL}}/pyo3/prelude/struct.PyErr.html#method.take
[`Python`]: {{#PYO3_DOCS_URL}}/pyo3/marker/struct.Python.html
[`FromPyObject`]: {{#PYO3_DOCS_URL}}/pyo3/conversion/trait.FromPyObject.html
[`pyo3::ffi::PyLong_AsUnsignedLongMask`]: {{#PYO3_DOCS_URL}}/pyo3/ffi/fn.PyLong_AsUnsignedLongMask.html