# åŸºæœ¬å¯¹è±¡è‡ªå®šä¹‰

å›æƒ³ä¸€ä¸‹å‰ä¸€ç« ä¸­çš„ `Number` ç±»ï¼š

```rust
# #![allow(dead_code)]
use pyo3::prelude::*;

#[pyclass]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -> Self {
        Self(value)
    }
}

#[pymodule]
fn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Number>()?;
    Ok(())
}
```

æ­¤æ—¶ï¼ŒPython ä»£ç å¯ä»¥å¯¼å…¥è¯¥æ¨¡å—ï¼Œè®¿é—®ç±»å¹¶åˆ›å»ºç±»å®ä¾‹â€”â€”ä½†é™¤æ­¤ä¹‹å¤–æ²¡æœ‰å…¶ä»–åŠŸèƒ½ã€‚

```python
from my_module import Number

n = Number(5)
print(n)
```

```text
<builtins.Number object at 0x000002B4D185D7D0>
```

### å­—ç¬¦ä¸²è¡¨ç¤º

å®ƒç”šè‡³æ— æ³•æ‰“å°å‡ºç”¨æˆ·å¯è¯»çš„è¡¨ç¤ºï¼æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ `#[pymethods]` å—ä¸­å®šä¹‰ `__repr__` å’Œ `__str__` æ–¹æ³•æ¥ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬é€šè¿‡è®¿é—® `Number` ä¸­åŒ…å«çš„å€¼æ¥å®ç°è¿™ä¸€ç‚¹ã€‚

```rust
# use pyo3::prelude::*;
#
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    // å¯¹äº `__repr__`ï¼Œæˆ‘ä»¬å¸Œæœ›è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒPython ä»£ç å¯ä»¥ç”¨å®ƒæ¥é‡å»º
    // `Number`ï¼Œä¾‹å¦‚ `Number(5)`ã€‚
    fn __repr__(&self) -> String {
        // æˆ‘ä»¬ä½¿ç”¨ `format!` å®æ¥åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ª
        // æ ¼å¼å­—ç¬¦ä¸²ï¼Œåé¢è·Ÿç€ä»»æ„æ•°é‡çš„å‚æ•°ï¼Œè¿™äº›å‚æ•°æ›¿æ¢æ ¼å¼å­—ç¬¦ä¸²ä¸­çš„
        // `{}`ã€‚
        //
        //                       ğŸ‘‡ Rust ä¸­çš„å…ƒç»„å­—æ®µè®¿é—®ä½¿ç”¨ç‚¹
        format!("Number({})", self.0)
    }
    // `__str__` é€šå¸¸ç”¨äºåˆ›å»ºâ€œéæ­£å¼â€è¡¨ç¤ºï¼Œå› æ­¤æˆ‘ä»¬
    // ç›´æ¥è½¬å‘åˆ° `i32` çš„ `ToString` ç‰¹å¾å®ç°ï¼Œä»¥æ‰“å°ä¸€ä¸ªè£¸æ•°å­—ã€‚
    fn __str__(&self) -> String {
        self.0.to_string()
    }
}
```

è¦ä½¿ç”¨ `Display` ç‰¹å¾å®ç°è‡ªåŠ¨ç”Ÿæˆ `__str__` å®ç°ï¼Œå¯ä»¥å°† `str` å‚æ•°ä¼ é€’ç»™ `pyclass`ã€‚

```rust
# use std::fmt::{Display, Formatter};
# use pyo3::prelude::*;
#
# #[allow(dead_code)]
# #[pyclass(str)]
# struct Coordinate {
    x: i32,
    y: i32,
    z: i32,
}

impl Display for Coordinate {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "({}, {}, {})", self.x, self.y, self.z)
    }
}
```

ä¸ºäº†æ–¹ä¾¿ï¼Œå¯ä»¥å°†ç®€å†™æ ¼å¼å­—ç¬¦ä¸²ä½œä¸º `str="<format string>"` ä¼ é€’ç»™ **ä»…é™ç»“æ„ä½“**ã€‚å®ƒä¼šå±•å¼€å¹¶ä»¥ä»¥ä¸‹æ–¹å¼ä¼ é€’ç»™ `format!` å®ï¼š

* `"{x}"` -> `"{}", self.x`
* `"{0}"` -> `"{}", self.0`
* `"{x:?}"` -> `"{:?}", self.x`

*æ³¨æ„ï¼šæ ¹æ®æ‚¨ä½¿ç”¨çš„æ ¼å¼å­—ç¬¦ä¸²ï¼Œè¿™å¯èƒ½éœ€è¦ä¸ºç»™å®šçš„ Rust ç±»å‹å®ç° `Display` æˆ– `Debug` ç‰¹å¾ã€‚*  
*æ³¨æ„ï¼špyclass å‚æ•° `name` å’Œ `rename_all` ä¸ç®€å†™æ ¼å¼å­—ç¬¦ä¸²ä¸å…¼å®¹ï¼Œå¹¶ä¼šå¼•å‘ç¼–è¯‘æ—¶é”™è¯¯ã€‚*

```rust
# use pyo3::prelude::*;
#
# #[allow(dead_code)]
# #[pyclass(str="({x}, {y}, {z})")]
# struct Coordinate {
    x: i32,
    y: i32,
    z: i32,
}
```

#### è®¿é—®ç±»å

åœ¨ `__repr__` ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ç¡¬ç¼–ç çš„ç±»åã€‚è¿™æœ‰æ—¶å¹¶ä¸ç†æƒ³ï¼Œå› ä¸ºå¦‚æœç±»åœ¨ Python ä¸­è¢«å­ç±»åŒ–ï¼Œæˆ‘ä»¬å¸Œæœ› repr åæ˜ å­ç±»åã€‚è¿™é€šå¸¸é€šè¿‡è®¿é—® `self.__class__.__name__` åœ¨ Python ä»£ç ä¸­å®Œæˆã€‚ä¸ºäº†èƒ½å¤Ÿè®¿é—® Python ç±»å‹ä¿¡æ¯ *å’Œ* Rust ç»“æ„ä½“ï¼Œæˆ‘ä»¬éœ€è¦å°† `Bound` ç”¨ä½œ `self` å‚æ•°ã€‚

```rust
# use pyo3::prelude::*;
# use pyo3::types::PyString;
#
# #[allow(dead_code)]
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {
        // è¿™ç›¸å½“äº Python ä¸­çš„ `self.__class__.__name__`ã€‚
        let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;
        // è¦è®¿é—® Rust ç»“æ„ä½“çš„å­—æ®µï¼Œæˆ‘ä»¬éœ€è¦å€Ÿç”¨ `PyCell`ã€‚
        Ok(format!("{}({})", class_name, slf.borrow().0))
    }
}
```

### å“ˆå¸Œ

è®©æˆ‘ä»¬ä¹Ÿå®ç°å“ˆå¸Œã€‚æˆ‘ä»¬å°†ä»…å¯¹ `i32` è¿›è¡Œå“ˆå¸Œã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ª [`Hasher`]ã€‚`std` æä¾›çš„ä¸€ä¸ªæ˜¯ [`DefaultHasher`]ï¼Œå®ƒä½¿ç”¨ [SipHash] ç®—æ³•ã€‚

```rust
use std::collections::hash_map::DefaultHasher;

// éœ€è¦è°ƒç”¨ `.hash` å’Œ `.finish` æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•åœ¨ç‰¹å¾ä¸Šå®šä¹‰ã€‚
use std::hash::{Hash, Hasher};

# use pyo3::prelude::*;
#
# #[allow(dead_code)]
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __hash__(&self) -> u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&mut hasher);
        hasher.finish()
    }
}
```
è¦ä½¿ç”¨ Rust çš„ [`Hash`] ç‰¹å¾å®ç°æ¥å®ç° `__hash__`ï¼Œå¯ä»¥ä½¿ç”¨ `hash` é€‰é¡¹ã€‚æ­¤é€‰é¡¹ä»…é€‚ç”¨äº `frozen` ç±»ï¼Œä»¥é˜²æ­¢æ„å¤–å“ˆå¸Œæ›´æ”¹å¯¼è‡´å¯¹è±¡å˜å¼‚ã€‚å¦‚æœæ‚¨éœ€è¦ä¸ºå¯å˜ç±»å®ç° `__hash__`ï¼Œè¯·ä½¿ç”¨ä¸Šé¢çš„æ‰‹åŠ¨æ–¹æ³•ã€‚æ­¤é€‰é¡¹è¿˜è¦æ±‚ `eq`ï¼šæ ¹æ® [Python æ–‡æ¡£](https://docs.python.org/3/reference/datamodel.html#object.__hash__) â€œå¦‚æœä¸€ä¸ªç±»æ²¡æœ‰å®šä¹‰ `__eq__()` æ–¹æ³•ï¼Œå®ƒä¹Ÿä¸åº”è¯¥å®šä¹‰ `__hash__()` æ“ä½œã€‚â€

```rust
# use pyo3::prelude::*;
#
# #[allow(dead_code)]
#[pyclass(frozen, eq, hash)]
#[derive(PartialEq, Hash)]
struct Number(i32);
```

> **æ³¨æ„**ï¼šåœ¨å®ç° `__hash__` å’Œæ¯”è¾ƒæ—¶ï¼Œç¡®ä¿ä»¥ä¸‹å±æ€§æˆç«‹æ˜¯å¾ˆé‡è¦çš„ï¼š
>
> ```text
> k1 == k2 -> hash(k1) == hash(k2)
> ```
>
> æ¢å¥è¯è¯´ï¼Œå¦‚æœä¸¤ä¸ªé”®ç›¸ç­‰ï¼Œå®ƒä»¬çš„å“ˆå¸Œå€¼ä¹Ÿå¿…é¡»ç›¸ç­‰ã€‚æ­¤å¤–ï¼Œæ‚¨å¿…é¡»ç¡®ä¿ç±»çš„å“ˆå¸Œåœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ä¸ä¼šæ”¹å˜ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä¸è®© Python ä»£ç æ›´æ”¹æˆ‘ä»¬çš„ `Number` ç±»æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒæ˜¯ä¸å¯å˜çš„ã€‚
>
> é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰ `#[pyclass]` ç±»å‹éƒ½æœ‰æ¥è‡ª Python çš„é»˜è®¤å“ˆå¸Œå®ç°ã€‚
> ä¸åº”å¯å“ˆå¸Œçš„ç±»å‹å¯ä»¥é€šè¿‡å°† `__hash__` è®¾ç½®ä¸º None æ¥è¦†ç›–æ­¤è¡Œä¸ºã€‚
> è¿™ä¸çº¯ Python ç±»çš„æœºåˆ¶ç›¸åŒã€‚è¿™æ ·åšå¦‚ä¸‹ï¼š
>
> ```rust
> # use pyo3::prelude::*;
> #[pyclass]
> struct NotHashable {}
>
> #[pymethods]
> impl NotHashable {
>     #[classattr]
>     const __hash__: Option<Py<PyAny>> = None;
> }
> ```

### æ¯”è¾ƒ

PyO3 æ”¯æŒ Python ä¸­å¯ç”¨çš„å¸¸è§é­”æ³•æ¯”è¾ƒæ–¹æ³•ï¼Œå¦‚ `__eq__`ã€`__lt__` ç­‰ã€‚ä¹Ÿå¯ä»¥é€šè¿‡ `__richcmp__` åŒæ—¶æ”¯æŒæ‰€æœ‰å…­ä¸ªæ“ä½œã€‚æ­¤æ–¹æ³•å°†æ ¹æ®æ“ä½œä½¿ç”¨ `CompareOp` çš„å€¼è¿›è¡Œè°ƒç”¨ã€‚

```rust
use pyo3::class::basic::CompareOp;

# use pyo3::prelude::*;
#
# #[allow(dead_code)]
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {
        match op {
            CompareOp::Lt => Ok(self.0 < other.0),
            CompareOp::Le => Ok(self.0 <= other.0),
            CompareOp::Eq => Ok(self.0 == other.0),
            CompareOp::Ne => Ok(self.0 != other.0),
            CompareOp::Gt => Ok(self.0 > other.0),
            CompareOp::Ge => Ok(self.0 >= other.0),
        }
    }
}
```

å¦‚æœæ‚¨é€šè¿‡æ¯”è¾ƒä¸¤ä¸ª Rust å€¼æ¥è·å¾—ç»“æœï¼Œå¦‚æœ¬ç¤ºä¾‹æ‰€ç¤ºï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `CompareOp::matches` è¿›è¡Œç®€åŒ–ï¼š

```rust
use pyo3::class::basic::CompareOp;

# use pyo3::prelude::*;
#
# #[allow(dead_code)]
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __richcmp__(&self, other: &Self, op: CompareOp) -> bool {
        op.matches(self.0.cmp(&other.0))
    }
}
```

å®ƒæ£€æŸ¥ä» Rust çš„ `Ord` è·å¾—çš„ `std::cmp::Ordering` æ˜¯å¦ä¸ç»™å®šçš„ `CompareOp` åŒ¹é…ã€‚

æˆ–è€…ï¼Œæ‚¨å¯ä»¥ä»…ä½¿ç”¨ `__eq__` å®ç°ç›¸ç­‰ï¼š

```rust
# use pyo3::prelude::*;
#
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __eq__(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

# fn main() -> PyResult<()> {
#     Python::with_gil(|py| {
#         let x = &Bound::new(py, Number(4))?;
#         let y = &Bound::new(py, Number(4))?;
#         assert!(x.eq(y)?);
#         assert!(!x.ne(y)?);
#         Ok(())
#     })
# }
```

è¦ä½¿ç”¨ Rust çš„ [`PartialEq`] ç‰¹å¾å®ç°æ¥å®ç° `__eq__`ï¼Œå¯ä»¥ä½¿ç”¨ `eq` é€‰é¡¹ã€‚

```rust
# use pyo3::prelude::*;
#
# #[allow(dead_code)]
#[pyclass(eq)]
#[derive(PartialEq)]
struct Number(i32);
```

è¦ä½¿ç”¨ Rust çš„ `PartialOrd` ç‰¹å¾å®ç°æ¥å®ç° `__lt__`ã€`__le__`ã€`__gt__` å’Œ `__ge__`ï¼Œå¯ä»¥ä½¿ç”¨ `ord` é€‰é¡¹ã€‚*æ³¨æ„ï¼šéœ€è¦ `eq`ã€‚*

```rust
# use pyo3::prelude::*;
#
# #[allow(dead_code)]
#[pyclass(eq, ord)]
#[derive(PartialEq, PartialOrd)]
struct Number(i32);
```

### çœŸå€¼

æˆ‘ä»¬å°†è®¤ä¸º `Number` åœ¨éé›¶æ—¶ä¸º `True`ï¼š

```rust
# use pyo3::prelude::*;
#
# #[allow(dead_code)]
# #[pyclass]
# struct Number(i32);
#
#[pymethods]
impl Number {
    fn __bool__(&self) -> bool {
        self.0 != 0
    }
}
```

### æœ€ç»ˆä»£ç 

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use pyo3::prelude::*;
use pyo3::class::basic::CompareOp;
use pyo3::types::PyString;

#[pyclass]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -> Self {
        Self(value)
    }

    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {
        let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;
        Ok(format!("{}({})", class_name, slf.borrow().0))
    }

    fn __str__(&self) -> String {
        self.0.to_string()
    }

    fn __hash__(&self) -> u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&mut hasher);
        hasher.finish()
    }

    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {
        match op {
            CompareOp::Lt => Ok(self.0 < other.0),
            CompareOp::Le => Ok(self.0 <= other.0),
            CompareOp::Eq => Ok(self.0 == other.0),
            CompareOp::Ne => Ok(self.0 != other.0),
            CompareOp::Gt => Ok(self.0 > other.0),
            CompareOp::Ge => Ok(self.0 >= other.0),
        }
    }

    fn __bool__(&self) -> bool {
        self.0 != 0
    }
}

#[pymodule]
fn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Number>()?;
    Ok(())
}
```

[`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html  
[`Hasher`]: https://doc.rust-lang.org/std/hash/trait.Hasher.html  
[`DefaultHasher`]: https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html  
[SipHash]: https://en.wikipedia.org/wiki/SipHash  
[`PartialEq`]: https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html